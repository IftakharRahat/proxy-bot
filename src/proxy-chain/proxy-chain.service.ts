import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../prisma/prisma.service';
import { exec } from 'child_process';
import * as fs from 'fs';
import * as util from 'util';

const execAsync = util.promisify(exec);

@Injectable()
export class ProxyChainService implements OnModuleInit {
    private readonly logger = new Logger(ProxyChainService.name);
    private configPath: string;
    private reloadCommand: string;

    constructor(
        private prisma: PrismaService,
        private configService: ConfigService,
    ) {
        this.configPath = this.configService.get<string>('PROXY_CONFIG_PATH') || '/etc/3proxy/3proxy.cfg';
        // Nuclear restart: ensure everything is dead before starting
        this.reloadCommand = this.configService.get<string>('PROXY_RELOAD_COMMAND') || 'killall -9 3proxy; systemctl restart 3proxy';
    }

    async onModuleInit() {
        this.logger.log('Initializing ProxyChainService... Triggering initial config rebuild.');
        await this.rebuildConfig();
    }

    /**
     * Rebuild 3proxy.cfg from database state
     */
    async rebuildConfig() {
        this.logger.log('Rebuilding 3proxy configuration...');

        const sharedPorts = await this.prisma.port.findMany({
            where: {
                isActive: true,
                packageType: { in: ['Normal', 'Medium'] },
                host: { not: '' },
            },
            include: {
                sessions: {
                    where: { status: 'ACTIVE' },
                },
            },
        });

        // 1. Generate Global Users List
        const allSessions = sharedPorts.flatMap(p => p.sessions);
        const usersList = ['test:CL:test'];
        for (const s of allSessions) {
            usersList.push(`${s.proxyUser}:CL:${s.proxyPass}`);
        }

        // 2. Start config content - GLOBAL LEVEL
        let config = `# Auto-generated by ProxyBot
daemon
nserver 8.8.8.8
nserver 1.1.1.1
nscache 65536
timeouts 1 5 30 60 180 1800 15 60

# User database and Global Auth
users ${usersList.join(' ')}
auth strong
allow *

# --- Port Definitions ---

# Diagnostics Port (Direct)
proxy -p30000

`;

        // 3. Generate Port/Chain definitions - NO FLUSH
        for (const port of sharedPorts) {
            if (port.upstreamHost && port.upstreamPort && port.localPort) {
                config += `# Port ${port.id} (${port.country})\n`;

                const upUser = port.upstreamUser || '';
                const upPass = port.upstreamPass || '';

                // Using 'connect' instead of 'tcp' as it's more reliable for HTTP proxies
                if (upUser && upPass) {
                    config += `parent 1000 connect ${port.upstreamHost} ${port.upstreamPort} ${upUser} ${upPass}\n`;
                } else {
                    config += `parent 1000 connect ${port.upstreamHost} ${port.upstreamPort}\n`;
                }

                // Restore bandwidth limits
                if (port.packageType === 'Normal') {
                    config += `bandlimin 125000 * \n`;
                    config += `bandlimout 125000 * \n`;
                } else if (port.packageType === 'Medium') {
                    config += `bandlimin 375000 * \n`;
                    config += `bandlimout 375000 * \n`;
                }

                config += `proxy -p${port.localPort}\n`;
                config += `socks -p${port.localPort + 5000}\n\n`;
            }
        }

        this.logger.log('Generated 3proxy config with Global-No-Flush pattern.');

        // 4. Write file
        try {
            if (process.platform !== 'win32') {
                await fs.promises.writeFile(this.configPath, config);
                this.logger.log(`Config written to ${this.configPath}`);

                // 5. Hard Restart
                await execAsync(this.reloadCommand);
                this.logger.log('3proxy service hard-restarted');
            } else {
                this.logger.log('Windows Environment detected. Skipping write/reload.');
            }
        } catch (error) {
            this.logger.error(`Failed to update 3proxy: ${error.message}`);
            // Don't throw, as it might block the main flow. Just log error.
        }
    }
}
