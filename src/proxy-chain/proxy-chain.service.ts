import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../prisma/prisma.service';
import { exec } from 'child_process';
import * as fs from 'fs';
import * as util from 'util';

const execAsync = util.promisify(exec);

@Injectable()
export class ProxyChainService implements OnModuleInit {
    private readonly logger = new Logger(ProxyChainService.name);
    private readonly configPath: string;
    private readonly reloadCommand: string;

    constructor(
        private readonly prisma: PrismaService,
        private readonly configService: ConfigService,
    ) {
        this.configPath =
            this.configService.get<string>('PROXY_CONFIG_PATH') ??
            '/etc/3proxy/3proxy.cfg';

        // Hard restart is safer than reload for 3proxy
        this.reloadCommand =
            this.configService.get<string>('PROXY_RELOAD_COMMAND') ??
            'systemctl restart 3proxy';
    }

    async onModuleInit() {
        this.logger.log('ProxyChainService initialized. Building config...');
        await this.rebuildConfig();
    }

    /**
     * Build 3proxy config from DB state
     * - Global users declared once
     * - No flush
     * - Per-port allow lists
     */
    async rebuildConfig() {
        this.logger.log('Rebuilding 3proxy config (GLOBAL USERS, NO FLUSH, MONITOR ENABLED)');

        const ports = await this.prisma.port.findMany({
            where: {
                isActive: true,
                host: { not: '' },
            },
            include: {
                sessions: {
                    where: { status: 'ACTIVE' },
                },
            },
        });

        /* ─────────────────────────────────────────────
           1️⃣ GLOBAL USER REGISTRY (DECLARED ONCE)
        ───────────────────────────────────────────── */

        const globalUsers = new Map<string, string>();

        // Diagnostic user
        globalUsers.set('test', 'test');

        for (const port of ports) {
            for (const session of port.sessions) {
                globalUsers.set(session.proxyUser, session.proxyPass);
            }
        }

        const usersLine =
            'users ' +
            [...globalUsers.entries()]
                .map(([u, p]) => `${u}:CL:${p}`)
                .join(' ');

        /* ─────────────────────────────────────────────
           2️⃣ CONFIG HEADER (GLOBAL SETTINGS)
        ───────────────────────────────────────────── */

        let config = `
# =====================================
# AUTO-GENERATED BY ProxyChainService
# =====================================

daemon
monitor ${this.configPath}

log /var/log/3proxy.log D
logformat "L%t.%. %N.%p %E %U %C:%c %R:%r %O %I %h %T"

nserver 1.1.1.1
nserver 8.8.8.8
nscache 65536
timeouts 1 5 30 60 180 1800 15 60

# -------- GLOBAL USER DATABASE --------
${usersLine}

# -------- GLOBAL AUTH LOGIC --------
auth strong

# -------- DIAGNOSTIC PORT (30000) --------
allow test * * * 30000
proxy -p30000
`;

        /* ─────────────────────────────────────────────
           3️⃣ PER-PORT ISOLATED SERVICES
        ───────────────────────────────────────────── */

        for (const port of ports) {
            if (!port.localPort || !port.upstreamHost || !port.upstreamPort) continue;

            const allowedUsers = ['test', ...port.sessions.map(s => s.proxyUser)];
            const userList = allowedUsers.join(',');
            const socksPort = port.localPort + 5000;
            const parentBase = `${port.upstreamHost} ${port.upstreamPort}${port.upstreamUser ? ` ${port.upstreamUser} ${port.upstreamPass}` : ''}`;

            config += `
# -------- PORT ${port.localPort} (${port.country ?? 'N/A'}) --------
# Isolated Parents
parent 1000 http ${parentBase} * * * ${port.localPort}
parent 1000 http ${parentBase} * * * ${socksPort}

# Isolated ACLs
allow ${userList} * * * ${port.localPort}
allow ${userList} * * * ${socksPort}

proxy -p${port.localPort}
socks -p${socksPort}
`;
        }

        // Safety Catch-all (Prevent IP Leakage)
        config += `\ndeny *\n`;

        /* ─────────────────────────────────────────────
           4️⃣ WRITE ONLY (NO RESTART)
        ───────────────────────────────────────────── */

        try {
            if (process.platform !== 'win32') {
                await fs.promises.writeFile(this.configPath, config.trim() + '\n');
                this.logger.log(`3proxy config written to ${this.configPath}. Monitor will auto-reload.`);

                // REMOVED: Explicit restart command. 
                // We rely on 'monitor' to reload the config gracefully.
                // const { stdout, stderr } = await execAsync(this.reloadCommand);

            } else {
                this.logger.warn('Windows detected: config generation only (dry run)');
            }
        } catch (err) {
            this.logger.error('3proxy rebuild failed', err.stack);
        }
    }
}
