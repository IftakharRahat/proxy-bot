import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../prisma/prisma.service';
import { exec } from 'child_process';
import * as fs from 'fs';
import * as util from 'util';

const execAsync = util.promisify(exec);

@Injectable()
export class ProxyChainService implements OnModuleInit {
    private readonly logger = new Logger(ProxyChainService.name);
    private configPath: string;
    private reloadCommand: string;

    constructor(
        private prisma: PrismaService,
        private configService: ConfigService,
    ) {
        this.configPath = this.configService.get<string>('PROXY_CONFIG_PATH') || '/etc/3proxy/3proxy.cfg';
        // Nuclear restart for absolute reliability
        this.reloadCommand = this.configService.get<string>('PROXY_RELOAD_COMMAND') || 'killall -9 3proxy; systemctl restart 3proxy; netstat -tulpn | grep 3proxy';
    }

    async onModuleInit() {
        this.logger.log('Initializing ProxyChainService... Triggering initial config rebuild.');
        await this.rebuildConfig();
    }

    /**
     * Rebuild 3proxy.cfg from database state
     */
    async rebuildConfig() {
        this.logger.log('Rebuilding 3proxy configuration with Self-Contained Power Blocks...');

        const sharedPorts = await this.prisma.port.findMany({
            where: {
                isActive: true,
                packageType: { in: ['Normal', 'Medium'] },
                host: { not: '' },
            },
            include: {
                sessions: {
                    where: { status: 'ACTIVE' },
                },
            },
        });

        // 1. Prepare User Registry (needed for every block)
        const allSessions = sharedPorts.flatMap(p => p.sessions);
        const usersList = ['test:CL:test'];
        for (const s of allSessions) {
            usersList.push(`${s.proxyUser}:CL:${s.proxyPass}`);
        }
        const usersLine = `users ${usersList.join(' ')}\n`;

        // 2. Start config header
        let config = `# Auto-generated by ProxyBot
daemon
nserver 8.8.8.8
nserver 1.1.1.1
nscache 65536
timeouts 1 5 30 60 180 1800 15 60

# --- Port Definitions (Isolated Blocks) ---

# Diagnostics Port (Direct)
flush
${usersLine}auth strong
allow test
proxy -p30000

`;

        // 3. Generate Port/Chain definitions
        for (const port of sharedPorts) {
            if (port.upstreamHost && port.upstreamPort && port.localPort) {
                config += `# Port ${port.id} (${port.country})\n`;
                config += `flush\n`;
                config += usersLine;

                const upUser = port.upstreamUser || '';
                const upPass = port.upstreamPass || '';

                // Upstream Chain - Using 'http' type for authenticated parents
                if (upUser && upPass) {
                    config += `parent 1000 http ${port.upstreamHost} ${port.upstreamPort} ${upUser} ${upPass}\n`;
                } else {
                    config += `parent 1000 http ${port.upstreamHost} ${port.upstreamPort}\n`;
                }

                // Auth and ACL
                const allowedUsers = ['test', ...port.sessions.map(s => s.proxyUser)];
                config += `auth strong\n`;
                config += `allow ${allowedUsers.join(',')}\n`;

                // Bandwidth limits
                if (port.packageType === 'Normal') {
                    config += `bandlimin 125000 * \n`;
                    config += `bandlimout 125000 * \n`;
                } else if (port.packageType === 'Medium') {
                    config += `bandlimin 375000 * \n`;
                    config += `bandlimout 375000 * \n`;
                }

                // Services
                config += `proxy -p${port.localPort}\n`;
                config += `socks -p${port.localPort + 5000}\n\n`;
            }
        }

        this.logger.log('Generated 3proxy config using Power Block pattern.');

        // 4. Write file and Restart
        try {
            if (process.platform !== 'win32') {
                await fs.promises.writeFile(this.configPath, config);
                this.logger.log(`Config written to ${this.configPath}`);

                // Execute Nuclear Restart
                const { stdout } = await execAsync(this.reloadCommand);
                this.logger.log('3proxy nuclear-restarted. Active ports check:\n' + stdout);
            } else {
                this.logger.log('Windows Environment detected. Skipping write/reload.');
            }
        } catch (error) {
            this.logger.error(`Failed to update 3proxy: ${error.message}`);
        }
    }
}
