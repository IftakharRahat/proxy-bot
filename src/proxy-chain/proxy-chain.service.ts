import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../prisma/prisma.service';
import { exec } from 'child_process';
import * as fs from 'fs';
import * as util from 'util';

const execAsync = util.promisify(exec);

@Injectable()
export class ProxyChainService {
    private readonly logger = new Logger(ProxyChainService.name);
    private configPath: string;
    private reloadCommand: string;

    constructor(
        private prisma: PrismaService,
        private configService: ConfigService,
    ) {
        this.configPath = this.configService.get<string>('PROXY_CONFIG_PATH') || '/etc/3proxy/3proxy.cfg';
        this.reloadCommand = this.configService.get<string>('PROXY_RELOAD_COMMAND') || 'systemctl reload 3proxy';
    }

    /**
     * Rebuild 3proxy.cfg from database state
     */
    async rebuildConfig() {
        this.logger.log('Rebuilding 3proxy configuration...');

        // 1. Fetch all Shared Ports (Normal/Medium) and their active sessions
        const sharedPorts = await this.prisma.port.findMany({
            where: {
                isActive: true,
                packageType: { in: ['Normal', 'Medium'] },
                host: { not: '' }, // Should use strict check for VPS IP if possible
            },
            include: {
                sessions: {
                    where: { status: 'ACTIVE' },
                },
            },
        });

        // 2. Start config content
        let config = `# Auto-generated by ProxyBot
daemon
nserver 8.8.8.8
nserver 1.1.1.1
nscache 65536
timeouts 1 5 30 60 180 1800 15 60
setgid 65535
setuid 65535
flush
auth strong
`;

        // 3. Generate 'users' line
        // Collect all distinct users from all sessions
        const allSessions = sharedPorts.flatMap(p => p.sessions);
        let userEntries: string[] = [];
        if (allSessions.length > 0) {
            userEntries = allSessions.map(s => `${s.proxyUser}:CL:${s.proxyPass}`);
        }

        // Always add debug user
        userEntries.push('test:CL:test');

        config += `users ${userEntries.join(' ')}\n\n`;

        // 4. Generate Port/Chain definitions
        for (const port of sharedPorts) {
            // Only convert ports that have upstream info
            if (port.upstreamHost && port.upstreamPort && port.localPort) {
                config += `# Port ${port.id} (${port.country}) - ${port.packageType}\n`;

                // Allow users assigned to this port
                if (port.sessions.length > 0) {
                    const allowedUsers = port.sessions.map(s => s.proxyUser).join(' ');
                    config += `allow ${allowedUsers}\n`;
                } else {
                    config += `allow * \n`; // Or deny? If empty, no one connects anyway
                }

                // Parent (Upstream)
                // Syntax: parent <weight> <type> <ip> <port> <user> <pass>
                // Type tcp=1000
                const upUser = port.upstreamUser || '';
                const upPass = port.upstreamPass || '';

                // If upstream has auth
                if (upUser && upPass) {
                    config += `parent 1000 tcp ${port.upstreamHost} ${port.upstreamPort} ${upUser} ${upPass}\n`;
                } else {
                    config += `parent 1000 tcp ${port.upstreamHost} ${port.upstreamPort}\n`;
                }

                // Proxy (Entry)
                // Traffic Shaping (Bandwidth Limits)
                if (port.packageType === 'Normal') {
                    config += `bandlimin 125000 * \n`;
                    config += `bandlimout 125000 * \n`;
                } else if (port.packageType === 'Medium') {
                    config += `bandlimin 375000 * \n`;
                    config += `bandlimout 375000 * \n`;
                }

                config += `proxy -p${port.localPort}\n`;

                // SOCKS5 Support (Offset by 5000)
                config += `socks -p${port.localPort + 5000}\n`;
                config += `flush\n\n`;
            }
        }

        // 5. Write file
        try {
            // Only write if not on Windows (Dev mode check)
            if (process.platform !== 'win32') {
                await fs.promises.writeFile(this.configPath, config);
                this.logger.log(`Config written to ${this.configPath}`);

                // 6. Reload service
                await execAsync(this.reloadCommand);
                this.logger.log('3proxy service reloaded');
            } else {
                this.logger.log('Windows Environment detected. Skipping file write/reload. Config content:\n' + config);
            }
        } catch (error) {
            this.logger.error(`Failed to update 3proxy: ${error.message}`);
            // Don't throw, as it might block the main flow. Just log error.
        }
    }
}
